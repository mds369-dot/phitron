# Module 2

1. Traversal
2. Level -> Shorest path
3. Path Printing - trying করবো
4. Task (same more task)

# Breadth First Search (BFS)

Breadth First Search (BFS) একটি গ্রাফ বা ট্রি-ভিত্তিক অ্যালগরিদম যা কোনো গ্রাফের বা ট্রির একটি নির্দিষ্ট নোড থেকে শুরু করে সমস্ত নোডগুলি ভিজিট করে। এটি প্রথমে নোডের কাছাকাছি থাকা নোডগুলি ভিজিট করে এবং তারপর ধীরে ধীরে দূরের নোডগুলিতে যায়। BFS সাধারণত কিউ (queue) ডেটা স্ট্রাকচার ব্যবহার করে যেখানে নোডগুলোকে প্রক্রিয়াকরণের জন্য রাখা হয়।

BFS এর সাধারণ কার্যপ্রণালী:

1. প্রথমে শুরুর নোডটিকে কিউতে রাখুন এবং সেটিকে ভিজিট হিসেবে চিহ্নিত করুন।
2. এরপর কিউ থেকে একটি নোড বের করুন এবং সেটির সব আনভিজিটেড প্রতিবেশী নোডগুলোকে কিউতে রাখুন।
3. এই প্রক্রিয়াটি পুনরাবৃত্তি করুন যতক্ষণ না সমস্ত নোডগুলো ভিজিট করা হয় বা কিউ খালি হয়ে যায়।

এভাবে BFS অ্যালগরিদমটি লেভেল-ওয়ার (level-wise) অনুসন্ধান করে। একে গ্রাফে সর্বনিম্ন পথ খুঁজতে (shortest path) এবং কানেক্টেড কম্পোনেন্টস খুঁজতে (connected components) ব্যবহার করা হয়।

BFS Traversal বলতে বোঝায় গ্রাফ বা ট্রির নোডগুলোকে একটি নির্দিষ্ট ক্রমে ভিজিট করা যেখানে প্রথমে একটি নোড এবং তার কাছাকাছি থাকা সব নোডগুলো ভিজিট করা হয়, তারপর সেই নোডগুলোর প্রতিবেশী নোডগুলো ভিজিট করা হয়। অর্থাৎ, BFS Traversal নোডগুলোকে লেভেল বাই লেভেল (level by level) বা স্তর অনুসারে ভিজিট করে।

**BFS Traversal এর স্টেপগুলো:**

1. **শুরুর নোড নির্বাচন:** প্রথমে যে নোড থেকে ট্রাভার্সাল শুরু করবেন, তাকে নির্বাচন করুন।
2. **কিউতে রাখুন:** শুরুর নোডটিকে কিউতে (queue) রাখুন এবং তাকে ভিজিট হিসেবে চিহ্নিত করুন।
3. **কিউ থেকে নোড বের করুন:** কিউ থেকে প্রথম নোডটি বের করুন এবং তাকে প্রসেস করুন (যেমন: প্রিন্ট করুন বা অন্য কোন কাজ করুন)।
4. **প্রতিবেশী নোডগুলোকে কিউতে যোগ করুন:** বর্তমানে যে নোডটি প্রক্রিয়াকরণ করছেন, তার সব আনভিজিটেড প্রতিবেশী নোডগুলোকে কিউতে যোগ করুন এবং তাদের ভিজিট হিসেবে চিহ্নিত করুন।
5. **পুনরাবৃত্তি করুন:** কিউ খালি না হওয়া পর্যন্ত এই প্রক্রিয়াটি পুনরাবৃত্তি করুন।

BFS Traversal এর ফলে আপনি নোডগুলোকে এমনভাবে ভিজিট করবেন যেন প্রথমে কাছাকাছি থাকা নোডগুলো ভিজিট হয়, তারপর দূরের নোডগুলো।

এই ট্রাভার্সাল পদ্ধতি খুবই কার্যকর যখন আপনাকে গ্রাফে দুটি নোডের মধ্যে সর্বনিম্ন পথ খুঁজে বের করতে হয়, বা কানেক্টেড কম্পোনেন্ট খুঁজে বের করতে হয়।

"BFS with Level Pair" বলতে বোঝানো হয় BFS অ্যালগরিদমের সাথে প্রতিটি নোডের লেভেল (অর্থাৎ, শুরু নোড থেকে সেই নোড পর্যন্ত যে স্তরে অবস্থিত) ট্র্যাক করা। সাধারণ BFS ট্রাভার্সালে কেবল নোডগুলো ভিজিট করা হয়, কিন্তু "BFS with Level Pair" এ প্রতিটি নোডের সাথে তার লেভেলও ধরে রাখা হয়।

**"BFS with Level Pair" এর মূল ধারণা:**

- এখানে প্রতিটি নোডের সাথে একটি লেভেল পেয়ার (node, level) হিসাবে কিউতে রাখা হয়।
- প্রথমে শুরুর নোডকে লেভেল 0 ধরে কিউতে রাখা হয়।
- এরপর যখন একটি নোড কিউ থেকে বের করা হয়, তখন তার লেভেল অনুসারে তার সব প্রতিবেশী নোডগুলিকে পরবর্তী লেভেল হিসেবে কিউতে রাখা হয়।

**কেন লেভেল ট্র্যাক করা গুরুত্বপূর্ণ?**

1. **Shortest Path Calculation:** যদি আপনাকে দুটি নোডের মধ্যে সর্বনিম্ন পথ খুঁজে বের করতে হয়, তবে লেভেল ট্র্যাক করার মাধ্যমে সহজে শুরুর নোড থেকে কোন নোডটি কত দূরে অবস্থিত তা জানা সম্ভব।

2. **Layered Traversal:** যদি আপনাকে গ্রাফ বা ট্রি লেভেল অনুযায়ী প্রসেস করতে হয়, তাহলে "BFS with Level Pair" ব্যবহার করে আপনি প্রতিটি লেভেলের নোডগুলি আলাদা করতে পারবেন।

**"BFS with Level Pair" এর একটি সরল উদাহরণ:**

ধরুন একটি ট্রি বা গ্রাফ আছে এবং শুরুর নোড A থেকে BFS ট্রাভার্সাল শুরু করতে হবে:

1. শুরুর নোড `A` কে লেভেল `0` ধরে কিউতে রাখুন। তাই কিউ হবে: `[(A, 0)]`
2. কিউ থেকে `A` কে বের করুন এবং তার প্রতিবেশীদের (B, C) কে লেভেল 1 ধরে কিউতে রাখুন। এখন কিউ হবে: `[(B, 1), (C, 1)]`
3. এরপর `B` কে কিউ থেকে বের করে তার প্রতিবেশীদের (D) কে লেভেল 2 ধরে কিউতে রাখুন। এখন কিউ হবে: `[(C, 1), (D, 2)]`
4. এই প্রক্রিয়া কিউ খালি না হওয়া পর্যন্ত চালিয়ে যান।

এইভাবে, আপনি শুধুমাত্র নোডগুলিকে ভিজিট করছেন না, বরং তাদের লেভেলও ট্র্যাক করছেন, যা অনেক ক্ষেত্রে উপকারী।

Breadth-First Search (BFS) অ্যালগরিদমের কমপ্লেক্সিটি বিশ্লেষণ করার সময় আমরা সাধারণত দুটি গুরুত্বপূর্ণ দিক বিবেচনা করি: টাইম কমপ্লেক্সিটি এবং স্পেস কমপ্লেক্সিটি।

### 1. **Time Complexity of BFS:**

BFS অ্যালগরিদমের টাইম কমপ্লেক্সিটি নির্ধারণ করা হয় গ্রাফের নোড (vertices) এবং এজ (edges) এর সংখ্যার উপর ভিত্তি করে।

- **Vertices (V):** গ্রাফে মোট নোডের সংখ্যা।
- **Edges (E):** গ্রাফে মোট এজের সংখ্যা।

BFS এর জন্য:

- প্রতিটি নোড কেবল একবারই ভিজিট করা হয়।
- প্রতিটি এজ কেবল একবারই প্রক্রিয়াকরণ করা হয়।

তাহলে, নোড এবং এজের উপর ভিত্তি করে BFS এর টাইম কমপ্লেক্সিটি হয়:

\[ \text{Time Complexity} = O(V + E) \]

এটি ব্যাখ্যা করা যায় এভাবে:

- `O(V)` হল সময়ের জটিলতা সমস্ত নোডগুলি ভিজিট করার জন্য।
- `O(E)` হল সময়ের জটিলতা সমস্ত এজগুলি প্রসেস করার জন্য।

এই কারণে, BFS অ্যালগরিদমের সময়ের জটিলতা একটি গ্রাফের নোড এবং এজের সংখ্যার সমষ্টি।

### 2. **Space Complexity of BFS:**

BFS অ্যালগরিদমের স্পেস কমপ্লেক্সিটি মূলত দুটি ডেটা স্ট্রাকচারের উপর নির্ভর করে:

- **Queue:** যেখানে নোডগুলোকে প্রক্রিয়াকরণের জন্য রাখা হয়।
- **Visited Array (বা Set):** যেখানে ভিজিট করা নোডগুলোর ট্র্যাক রাখা হয়।

- **Queue:** সর্বাধিক ক্ষেত্রে, কিউতে একবারে সর্বাধিক লেভেলের নোডগুলো থাকবে। যদি কোনও গ্রাফ সম্পূর্ণভাবে ব্যালান্সড থাকে, তাহলে একটি লেভেলে সর্বাধিক \( O(V) \) নোড থাকতে পারে। ফলে কিউ-এর স্পেস কমপ্লেক্সিটি হয় \( O(V) \)।
- **Visited Array/Set:** এটি প্রতিটি নোডকে চিহ্নিত করতে ব্যবহৃত হয়, যা সর্বাধিক \( O(V) \) স্পেস নেয়।

তাহলে, BFS এর স্পেস কমপ্লেক্সিটি হয়:

\[ \text{Space Complexity} = O(V) \]

### **Summary:**

- **Time Complexity:** \( O(V + E) \)
- **Space Complexity:** \( O(V) \)

এই কমপ্লেক্সিটি নির্ধারণ করে কতটা সময় এবং মেমোরি দরকার হবে BFS অ্যালগরিদম চালানোর জন্য।

Path Printing using BFS বলতে বোঝায় একটি গ্রাফে বা ট্রিতে দুইটি নোডের মধ্যে সরলতম পথটি খুঁজে বের করা এবং সেটি প্রিন্ট করা। BFS (Breadth-First Search) অ্যালগরিদমটি লেভেল-ওয়ার (level-wise) অনুসন্ধান করে, তাই এটি গ্রাফের মধ্যে সবচেয়ে কম সংখ্যক এজ ব্যবহার করে সরলতম পথটি খুঁজে বের করতে পারদর্শী।

### **কীভাবে Path Printing with BFS কাজ করে:**

1. **Queue এবং Visited Set ব্যবহার করা:** সাধারণ BFS এর মতো, একটি কিউ (queue) ব্যবহার করা হয় যা লেভেল অনুযায়ী নোডগুলিকে প্রক্রিয়াকরণের জন্য ধরে রাখে এবং একটি visited সেট ব্যবহার করা হয় যাতে ইতিমধ্যেই ভিজিট করা নোডগুলোর ট্র্যাক রাখা যায়।

2. **Parent Tracking:** একটি parent ডিকশনারি (dictionary) ব্যবহার করা হয় যা প্রতিটি নোডের পেরেন্ট নোড (যেখান থেকে ওই নোডে আসা হয়েছে) সংরক্ষণ করে। এটি পরবর্তীতে সরলতম পথটি খুঁজে বের করতে সহায়ক হয়।

3. **BFS Traversal:** BFS চালানোর সময় প্রতিটি নোডের প্রতিবেশী নোডগুলিকে কিউতে যোগ করার সময় parent ডিকশনারিতে সেই নোডের পেরেন্ট হিসেবে বর্তমান নোডের উল্লেখ রাখা হয়।

4. **Path Reconstruction:** যখন আপনি কোনো নির্দিষ্ট নোডের জন্য সরলতম পথটি খুঁজে পেতে চান, তখন parent ডিকশনারি ব্যবহার করে লক্ষ্য নোড থেকে শুরু নোড পর্যন্ত ব্যাকট্র্যাক করে সহজেই সেই পথটি পুনর্গঠন করা যায়।

### **একটি উদাহরণ:**

ধরা যাক, আপনার কাছে নিম্নলিখিত গ্রাফ রয়েছে এবং আপনাকে নোড `A` থেকে নোড `E` পর্যন্ত সরলতম পথটি খুঁজতে হবে।

```
    A
   / \
  B   C
   \   \
    D - E
```

**Step-by-Step Process:**

1. **Initialization:**

   - Queue: `[(A, 0)]`
   - Visited: `{A}`
   - Parent: `{A: None}`

2. **BFS Traversal and Parent Tracking:**

   - `A` থেকে `B` এবং `C` তে যাওয়া হবে।
   - Queue: `[B, C]`
   - Visited: `{A, B, C}`
   - Parent: `{A: None, B: A, C: A}`

   - এরপর `B` থেকে `D` তে যাওয়া হবে।
   - Queue: `[C, D]`
   - Visited: `{A, B, C, D}`
   - Parent: `{A: None, B: A, C: A, D: B}`

   - তারপর `C` থেকে `E` তে যাওয়া হবে।
   - Queue: `[D, E]`
   - Visited: `{A, B, C, D, E}`
   - Parent: `{A: None, B: A, C: A, D: B, E: C}`

3. **Path Reconstruction:**
   - `E` নোড থেকে শুরু করে, parent ডিকশনারি ব্যবহার করে `C`, তারপর `A` পর্যন্ত ব্যাকট্র্যাক করলে পথটি হবে `A -> C -> E`।

### **Summary:**

Path Printing using BFS হলো BFS অ্যালগরিদমের মাধ্যমে নোডগুলোর মধ্যে সরলতম পথ খুঁজে বের করা এবং সেই পথটি প্রিন্ট করা। এর মাধ্যমে আপনি গ্রাফের কোনো দুটি নোডের মধ্যে সর্বনিম্ন দূরত্বে থাকা পথটি বের করতে পারেন।
