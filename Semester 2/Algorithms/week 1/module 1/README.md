# Module 1

Graph (গ্রাফ)
গ্রাফ অ্যালগরিদম হলো এক ধরনের অ্যালগরিদম, যা গ্রাফ ডেটা স্ট্রাকচার ব্যবহার করে বিভিন্ন সমস্যার সমাধান করে। গ্রাফ হল একটি ডেটা স্ট্রাকচার যেখানে নোড (বা ভার্টেক্স) এবং এদের মধ্যে থাকা এজ (বা সংযোগ) নিয়ে গঠিত। গ্রাফের মাধ্যমে বিভিন্ন ধরনের সম্পর্ক এবং সংযোগ বোঝানো যায়, যেমন সোশ্যাল নেটওয়ার্কের সংযোগ, রাস্তার মানচিত্র ইত্যাদি।

**গ্রাফ অ্যালগরিদমের** কিছু সাধারণ প্রকারভেদ:

1. **Undirected Graph** দুই ডিরেকশন এ যেতে পরবে।

2. **Directed Graph** শুধু এক ডিকে ডিরেকশন এ যেতে পারে।

3. **Weighted Graph** সব গুলো এজ একটি weight থাকবে।

4. **Unweighted Graph** শুধু ১ ধরে, সব গুলোর weight একই।

5. **Cycle Undirected and Directed** ২ টি নোড এর জন্য সাউকেল ধরা হয় না। অন্তত্ত ৩ লাগবে বার অধিক লাগবে(Undirected)। । এক দিকেই যাবে। এবং অন্য দিকে যদি পারমিশন দেওয়া হয়, তখন যায়(Directed)।

6. **DFS (Depth First Search):** একটি নোড থেকে শুরু করে যতদূর সম্ভব একদিকে গিয়ে, তারপর ব্যাকট্র্যাক করে অন্যান্য পথ অনুসন্ধান করে।
7. **BFS (Breadth First Search):** একটি নোড থেকে শুরু করে, সমান দূরত্বের সব নোড প্রথমে পরিদর্শন করে, তারপর ধীরে ধীরে দূরত্ব বাড়িয়ে পরিদর্শন করে।

8. **Dijkstra’s Algorithm:** এটি একটি অ্যালগরিদম যা একটি নির্দিষ্ট নোড থেকে অন্য সব নোডের মধ্যে সবচেয়ে কম ওজনের পথ খুঁজে বের করে।

9. **Kruskal's এবং Prim's Algorithm:** এই অ্যালগরিদম দুটি গ্রাফের মধ্যে মিনিমাম স্প্যানিং ট্রি (MST) খুঁজে বের করে।

10. **Bellman-Ford Algorithm:** এটি এক ধরনের গ্রাফ অ্যালগরিদম, যা নেগেটিভ ওয়েটের পথের জন্যও কাজ করে, কিন্তু Dijkstra's Algorithm তা পারে না।

গ্রাফ অ্যালগরিদম বিভিন্ন ক্ষেত্রে ব্যবহৃত হয়, যেমন নেটওয়ার্ক রাউটিং, গেম ডেভেলপমেন্ট, মেশিন লার্নিং, এবং সোশ্যাল নেটওয়ার্ক বিশ্লেষণ।

**Adjacency Matrix** হলো একটি 2D অ্যারে বা ম্যাট্রিক্স যা একটি গ্রাফের নোডগুলো এবং এজগুলোর মধ্যে সম্পর্ক দেখানোর জন্য ব্যবহৃত হয়। এটি গ্রাফের প্রতিটি নোডের মধ্যে সংযোগ বা এজের উপস্থিতি বোঝায়।

### Adjacency Matrix এর গঠন:

- ধরা যাক, একটি গ্রাফে \(n\) টি নোড আছে।
- তাহলে, Adjacency Matrix হবে একটি \(n \times n\) ম্যাট্রিক্স \(A\), যেখানে \(A[i][j]\) নির্দেশ করে \(i\) এবং \(j\) নোডের মধ্যে একটি এজ আছে কি না।

### কীভাবে Adjacency Matrix কাজ করে:

1. **Unweighted Graph:**

   - যদি \(i\) এবং \(j\) নোডের মধ্যে এজ থাকে, তাহলে \(A[i][j] = 1\), আর যদি না থাকে, তাহলে \(A[i][j] = 0\)।
   - এটি Directed এবং Undirected গ্রাফ উভয়ের জন্যই প্রযোজ্য।
   - Undirected গ্রাফের ক্ষেত্রে, ম্যাট্রিক্সটি symmetric হয় (অর্থাৎ \(A[i][j] = A[j][i]\))।

2. **Weighted Graph:**
   - যদি \(i\) এবং \(j\) নোডের মধ্যে এজ থাকে, তাহলে \(A[i][j]\) হবে সেই এজের ওজন বা Weight।
   - আর যদি কোনো এজ না থাকে, তাহলে \(A[i][j] = 0\) (অথবা একটি বড় মান যেমন \( \infty \) ব্যবহার করা হয়)।

### উদাহরণ:

ধরা যাক, একটি গ্রাফে 4 টি নোড (0, 1, 2, 3) রয়েছে এবং এজগুলো হলো:

- 0 -> 1
- 0 -> 2
- 1 -> 2
- 2 -> 3

এই গ্রাফের জন্য Adjacency Matrix হবে:

|     | 0   | 1   | 2   | 3   |
| --- | --- | --- | --- | --- |
| 0   | 0   | 1   | 1   | 0   |
| 1   | 0   | 0   | 1   | 0   |
| 2   | 0   | 0   | 0   | 1   |
| 3   | 0   | 0   | 0   | 0   |

### Adjacency Matrix এর সুবিধা ও অসুবিধা:

**সুবিধা:**

- সংযোগ সহজে এবং দ্রুত খুঁজে পাওয়া যায়।
- মেমোরি ব্যবহারে কম্প্যাক্ট হয় যখন গ্রাফে অনেক এজ থাকে (Dense Graph)।

**অসুবিধা:**

- স্পার্স গ্রাফের ক্ষেত্রে, যেখানে কম এজ আছে, এটি অনেক বেশি মেমোরি ব্যবহার করতে পারে।
- গ্রাফে যদি খুব বেশি নোড থাকে, তবে এটি মেমোরি এবং প্রসেসিং উভয় ক্ষেত্রেই ভারী হতে পারে।

**Adjacency List** হলো গ্রাফের একটি প্রতিনিধিত্ব করার পদ্ধতি যেখানে প্রতিটি নোডের সাথে সংযুক্ত অন্যান্য নোডগুলোর তালিকা বা লিস্ট থাকে। এটি গ্রাফের নোডগুলো এবং তাদের সংযোগগুলো (এজ) সংরক্ষণের জন্য একটি দক্ষ এবং মেমোরি-সাশ্রয়ী উপায়।

### Adjacency List এর গঠন:

- প্রতিটি নোডের জন্য একটি লিস্ট থাকে।
- এই লিস্টে সেই সমস্ত নোডের তালিকা থাকে যেগুলোর সাথে ওই নোডের সরাসরি সংযোগ (এজ) রয়েছে।

### উদাহরণ:

ধরা যাক, একটি গ্রাফে 4টি নোড (0, 1, 2, 3) রয়েছে এবং এজগুলো হলো:

- 0 -> 1
- 0 -> 2
- 1 -> 2
- 2 -> 3

এই গ্রাফের জন্য Adjacency List হবে:

```
0: 1 -> 2
1: 2
2: 3
3: (empty)
```

### Adjacency List-এর সুবিধা ও অসুবিধা:

**সুবিধা:**

- **মেমোরি সাশ্রয়ী:** স্পার্স (Sparse) গ্রাফের জন্য মেমোরি খুব কম লাগে, কারণ শুধুমাত্র সংযুক্ত নোডগুলো সংরক্ষণ করা হয়।
- **ডাইনামিক:** এজ যোগ করা বা মুছে ফেলা সহজ, কারণ শুধুমাত্র সংশ্লিষ্ট নোডের লিস্ট আপডেট করতে হয়।
- **কোডিং সহজ:** এটি ইনপুট ডেটা থেকে সহজেই তৈরি করা যায়।

**অসুবিধা:**

- একটি নির্দিষ্ট নোডের মধ্যে এজ আছে কি না তা খুঁজে পেতে কিছুটা সময় বেশি লাগে, কারণ লিস্টের মধ্যে লিনিয়ার সার্চ করতে হয়।
- এটি Dense গ্রাফের জন্য উপযুক্ত নয়, কারণ অনেক এজ থাকলে লিস্টগুলো খুব দীর্ঘ হয়ে যেতে পারে, যা মেমোরি এবং প্রসেসিং সময় বাড়িয়ে দেয়।

### ব্যবহারের ক্ষেত্র:

- **সোশ্যাল নেটওয়ার্ক:** যেখানে একজন ইউজারের বন্ধুদের তালিকা দেখানোর জন্য এই ডেটা স্ট্রাকচার ব্যবহার করা যেতে পারে।
- **ওয়েব ক্রাউলিং:** যেখানে একটি ওয়েবপেজের লিংক করা অন্যান্য ওয়েবপেজগুলোর তথ্য সংরক্ষণ করা হয়।
- **নেভিগেশন সিস্টেম:** যেখানে একটি শহরের রাস্তার সংযোগের মানচিত্র তৈরি করা হয়।

**Adjacency List** সাধারণত Linked List, Hash Map বা Array ব্যবহার করে ইমপ্লিমেন্ট করা হয়। এটি বেশিরভাগ গ্রাফ-সম্পর্কিত অ্যালগরিদমে ব্যবহার করা হয়, কারণ এটি স্পেস এবং টাইম উভয় ক্ষেত্রেই কার্যকরী।

**Edge List** হলো গ্রাফের একটি প্রতিনিধিত্ব করার পদ্ধতি যেখানে শুধু এজগুলোর (সংযোগ) তালিকা সংরক্ষণ করা হয়। প্রতিটি এজ একটি জোড়া (pair) হিসেবে সংরক্ষিত হয়, যা গ্রাফের দুটি নোডের মধ্যে সংযোগ নির্দেশ করে।

### Edge List এর গঠন:

- প্রতিটি এজ (সংযোগ) দুটি নোড দ্বারা নির্ধারিত হয়।
- সাধারণত একটি লিস্ট বা অ্যারে ব্যবহার করে প্রতিটি এজকে নোডের একটি জোড়া হিসেবে সংরক্ষণ করা হয়।

### উদাহরণ:

ধরা যাক, একটি গ্রাফে 4টি নোড (0, 1, 2, 3) রয়েছে এবং এজগুলো হলো:

- 0 -> 1
- 0 -> 2
- 1 -> 2
- 2 -> 3

এই গ্রাফের জন্য Edge List হবে:

```
[(0, 1), (0, 2), (1, 2), (2, 3)]
```

### Weighted Graph-এর ক্ষেত্রে:

- যদি গ্রাফের এজগুলোর ওজন (weight) থাকে, তাহলে প্রত্যেকটি এজকে তিনটি মান দিয়ে প্রকাশ করা হয়: দুইটি নোড এবং তাদের মধ্যে এজের ওজন।

উদাহরণস্বরূপ, যদি উপরের গ্রাফের এজগুলোর ওজন থাকে, তাহলে Edge List হতে পারে:

```
[(0, 1, 4), (0, 2, 3), (1, 2, 2), (2, 3, 1)]
```

এখানে প্রতিটি ট্রিপলেট নির্দেশ করে `(নোড 1, নোড 2, ওজন)`।

### Edge List-এর সুবিধা ও অসুবিধা:

**সুবিধা:**

- **সাধারণ এবং সরল:** গ্রাফের এজগুলো সংরক্ষণের সরলতম উপায়।
- **মেমোরি সাশ্রয়ী:** স্পার্স গ্রাফের জন্য খুবই মেমোরি-সাশ্রয়ী, কারণ শুধুমাত্র এজগুলোই সংরক্ষণ করা হয়।
- **সংযোগ যোগ এবং অপসারণ:** সহজে নতুন এজ যোগ করা বা অপসারণ করা যায়, কারণ এটি শুধু একটি জোড়া যোগ করা বা মুছে ফেলার সমান।

**অসুবিধা:**

- **সংযোগ খুঁজে পাওয়া:** একটি নির্দিষ্ট নোডের সাথে কোন নোড সংযুক্ত আছে তা খুঁজে পেতে সময় লাগে, কারণ পুরো লিস্ট স্ক্যান করতে হয়।
- **অ্যাডজেসেন্সি (প্রতিনিধিত্ব) অনুপস্থিত:** কোন নোডের সাথে আরেকটি নোড সরাসরি সংযুক্ত কি না, তা খুঁজে পাওয়া তুলনামূলকভাবে জটিল।
- **Dense গ্রাফের জন্য অনুপযুক্ত:** যখন গ্রাফে অনেক এজ থাকে, তখন এটি অন্যান্য ডেটা স্ট্রাকচারগুলোর তুলনায় অকার্যকর হয়ে যেতে পারে।

### ব্যবহারের ক্ষেত্র:

- **গ্রাফের ছোট প্রদর্শন:** যেখানে এজ সংখ্যা কম থাকে।
- **গ্রাফ অ্যালগরিদম:** যেমন মিনিমাম স্প্যানিং ট্রি (MST) তৈরির অ্যালগরিদমে প্রাথমিকভাবে Edge List ব্যবহার করা হয়।
- **নেটওয়ার্ক বিশ্লেষণ:** যেখানে নির্দিষ্ট কিছু সংযোগের বিশ্লেষণ করা হয়।

Edge List সাধারণত তখন ব্যবহার করা হয় যখন গ্রাফের এজ সংখ্যা কম এবং সংযোগগুলি দেখতে সহজলভ্য হতে হয়।
